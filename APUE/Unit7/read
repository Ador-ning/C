#进程环境
	-- 当程序执行时，其main函数如何被调用
	-- 命令行参数如何传输
	-- 典型的存储空间布局
	-- 如何分配另外的存储空间
	-- 进程如何使用环境变量
	-- 进程的各种不同终止方式

#1 main()函数
####当内核执行C程序之前，在调用main之前先调用一个特殊的启动例程。可执行程序文件(.out)将此启动例程指定为程序的起始地址 -- 由连接编辑器设置。启动例程从内核取得命令和环境变量值。

#2 进程终止
####正常终止
A main返回 B 调用exit C 调用_exit或_Exit D 最后一个线程从其启动例程返回 E 从最后一个线程调用pthread_exit
####异常终止
A 调用abort B 接收到一个信号 C最后一个线程对取消请求作出响应

exit()函数总是执行一个标准IO库的清理关闭操作：对于所有打开流调用fclose()。
终止码 -- 随机／传参指定 -- 查看shell命令 echo $?

atexit() -- <stdlib.h>文件接口  登记函数，调用顺序与注册顺序相反

#3 环境表
####每个程序都接收到一张环境表，是一个字符指针数组，其中每个指针包含一个以null结束的C字符串地址
	extern char **environ;

#4 程序存储布局空间
####正文段 -- 执行的机器指令部分，可以共享，通常是只读属性
####初始化数据段
####未初始化数据段 -- bbs段，在程序执行前，内核将此段中的数据初始化为0或空指针
####栈 -- 自动变量； 函数调用保存( 栈帧结构 )
####堆 -- 进行动态内存分配
####a.out中还有其它若干类型的段--- 包含符号表的段； 包含调试信息的段；包含动态共享库连接的表，不装载到进程执行的程序镜像中。
######## 需要存放在磁盘程序文件中的段只有正文段和初始化数据段

Shell命令查看各段大小： size

#4 共享库

#5 存储空间分配	 <stdlib.h> 函数原型
malloc -- 分配指定字数的存储区，起始地址不确定
calloc -- 为指定数量指定长度的对象分配存储空间，初始化为0
realloc -- 重新分配，之前全部移动
########释放 -- 保持在malloc池中，以备下次使用
########错误 -- 内存泄漏  内存访问越界  分配频繁-系统缺页，进程空间变大

####实现 -- 系统调用sbrk(2) -- 扩从或缩小进程堆

####替代的存储空间分配程序
libmalloc    vmalloc   quick-fit   jemalloc  TCMalloc  allloca

#6 环境变量  -- 内核不查看字符串

#7 setjump longjump  -- 跨函数深层跳转
####goto -- 不能跨函数

####实现 -- 在栈帧上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中
int setjump(jmp_ptr env) -- 在希望返回的位置上调用；直接调用返回0，longjump调用返回非0
void longjmp(jmp_ptr env, int val) -- val为从setjump处返回的值

####对变量的影响(回滚) -- 全局变量 静态变量 volatile变量不受影响，开启优化

####函数中全局操作对象 -- 应该使用全局静态static或extern 或者进行动态内存分配

#8 进程资源限制 <sys/resource.h> -- 结构体rlimit
getrlimit() setrlimit()
####规则
a. 任何一个进程都可以将软限制值更改为小于或者等于其硬限制值
b. 任何一个进程都可以降低其硬限制值
c. 只有超级用户进程可以提高其硬限制值·
####Shell命令 ulimit

#15 进程间通信IPC 高级进程间通信
经典IPC -- 管道 FIFO 消息队列 信号量 共享存储

##1 管道 -- 每当在管道中键入一个命令序列，让shell执行时，shell都会为每一个命令单独创建一个进程，然后用管道将前一条命令的标准输出与后一条的标准输入相连接
int pipe(int fd[2]); <unistd.h>		fd[0] -- 为读打开，输入	fd[1] -- 为写打开，输出

#### 当管道的一端被关闭，规则
	A 当读一个写端已被关闭的管道，在所有数据都被读取后，read返回0，表示文件结束
	B 当写一个读端已被关闭的管道，则产生SIGPIPE
	C 在写管道／FIFO时。常量PIPE_BUF规定量内核的管道缓冲区大小

##2 函数poen pclose -- 创建一个管道，fork一个子进程。关闭未使用的管道端。执行一个shell命令，然后等待命令终止
常见操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据

##3 协同进程  当一个过滤程序即产生某个过滤程序的输入，又读取该过滤程序的输入时，是为协同进程
popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道；而协同进程则有两个连接到另一个进程的两个单向管道

##4 FIFO	-- 命令管道--不相关进程交换数据， 未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同创建它们的祖先进程
	##创建
int mkfifo(const char *path, mode_t mode);	<sys/stat.h>  stat结构体
int mkfifoat(int fd, const char *path, mode_t mode);
	##打开 open(), 标志O_NONBLOCK的影响
A 在一般情况下，没有指定该标志，只读open要阻塞到某个进程为写打开的FIFO为止
B open立即返回，但是没有进程为读而打开一个FIFO，那么open返回-1，errno设置为ENXIO
	##一个给定的FIFO有多个写进程正常，FIFO用途
A shell命令使用FIFO将数据从一条管道传送到另一条管道时，无需创建临时文件
B 在客户进程-服务器进程应用中，FIFO作为汇聚点，在客户和服务器二者之间传递数据

##5 XSI IPC	-- 消息队列  信号量 共享存储器的共同点
	##标识符和键
A 标识符-是IPC对象的内部命名，为使多个进程能够在同一IPC对象上汇聚，需要提供一个外部命名的方案，因此每个IPC对象都与一个键相关联，将键作为该对象外部的外部命名
B 客户和服务器进程在同一IPC汇聚方法
	1) 服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构，将返回的标识符存放以便客户进程取用
	2) 在一个公共头文件定义一个苦户和服务器进程都认可的键，然后服务器进程指定此键创建一个新IPC结构
	3) 苦户进程和服务器进程认同一个路径名和项目ID
key_t ftok(const char *path, int fd)	<sys/ipc.h>
msgget()--消息队列	semget()	shmget() 参数1-key	参数2-flag
	如果key是IPC_PRIVATE标志位或者和当前某种类型的IPC结构无关，则需要指定flag的IPC_PRIVATE标识位。

	##权限结构	每一个IPC结构关联ipc_perm结构
	##结构限制	sysctl命令来观察和修改内核配置	Linux中用 ipc -l
	##优缺点

##6 消息队列	-- 	是消息的链接表，存储在内核中，由消息队列标识符标识，队列ID
msgget--创建或打开队列	msgsnd--将消息添加到队列尾端	msgrcv--从队列中取消息(FIFO或消息类型字段取消息)
	结构体msqid_ds		msgctl--对队列执行多种操作		struct mymsg;

##7 信号量	-- 是一个计数器，用于为对个进程提供对共享数据对象的访问
内核为每个信号集合维护struct semid_ds

	exit时的信号调整--内核核查调整

##8 共享存储 	允许两个或多个进程共享一个给定的存储区
内核为每个共享存储区维护struct shmid_ds		函数shmctl()

##9 POSIX信号量

##10 高级进程间通信 -- SOCKET

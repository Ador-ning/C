#进程控制
含 进程创建 执行程序 进程终止  进程属性 进程控制原语 解释器文件 进程会话机制

#1 进程标识
####进程ID-PID -- 复用 0--调度进程 1--init进程，自举过程结束后内核调用
UNIX中在 /etc/init /sbin/init, 通常读取系统有关的初始化文件／etc/rc* 或者/etc/inittab以及／etc/init.d文件
2--页守护进程，负责支持虚拟存储器系统的分页操作
getpid() getppid()-父进程ID getuid()-实际用户ID geteuid()-有效用户ID getgid()-实际组ID getegid()-有效组ID

#2 创建进程 -- fork()
#### 1)由fork创建的新进程被称为子进程。函数被调用一次，但是返回两次。 子进程的返回值为0，父进程返回子是新建子进程的PID 2)子进程和父进程会继续执行之后指令。子进程是父进程的副本，并不共享存储空间部分，共享正文段 3) 很多时候并不执行一个父进程数据段栈和堆的完全副本。作为替代，使用流写时复制技术-COW ，修改共享区副本
4) strlen()函数调用不计算null字节； sizeof()计算null字节，在编译时计算缓冲区长度
5) fork()特性父进程和子进程每个相同的打开描述符共享一个文件表项； 共享同一个文件偏移量
6) fork()之后处理文件描述符常见情况：
	A 父进程等待子进程完成
	B 父进程和子进程各自执行不同的程序段
7) 子进程继承使用父进程属性： 一系列ID 控制终端 工作目录 文件模式 文件 环境 信号 链接共享段 存储映像 资源限制
8) 父子进程之间区别： ID time 不继承父进程设置的文件锁 未处理信号设置为空

#3 vfork() -- 用于创建新进程，目的是exec一个新程序，不将父进程的地址空间完全复制到子进程中，保证子进程先运行

#4 exit() -- 进程5种正常终止，3种异常终止； 1) 不管如何终止，最后都会执行内核中的一段相同代码。这段代码为相关进程关闭所有文件，释放它使用的存储器等 2) 进程通知父进程其终止状态，通过退出状态码作为参数进行传递，当其父进程终止将被init进程收养 3) 一个已经终止但是其父进程尚未对其进行善后处理的进程称为僵死进程，shell ps命令打印为Z--zombie

#5 wait() waitpid() -- 当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号（进程终止是异步事件） A 当所有子进程都还在运行，则阻塞 B 如果一个子进程终止，正在等待父进程获取其终止状态 C 如果没有任何子进程返回出错  终止状态定义在  <sys/wait.h>

wait3() wait4() -- 附加参数，允许内核返回由终止进程及其所有子进程使用的资源概况

#6 竞争条件 -- 利用管道		TELL_WAIT()等实现原理

#7 函数exec() -- 用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段
execl() execv() execle() execve()--系统调用 -- 取路径作为参数  execlp() execvp() -- 取文件名作为参数 fexecve() -- fd参数

#8 解释器文件 -- 脚本文件

#9 函数system() -- 其中实现fork() exec() waitpid()三个函数		例程对文件执行权限有问题

#10 进程会计 -- accton 命令启动进程会计  <sys/acct.h>会计记录结构体

#11 进程调度 -- 调度策略和调度优先级是由内核确定的，进程可以通过nice值调整运行优先级	<unistd.h>
nice() getpriority() setpriority()
#12 进程时间

补  <stdlib.h> -- 定义变量 const char **environ; -- 打印系统环境变量
printf("%s\n", *environ);  *environ != 0; environ++  [使用局部变量打印]
